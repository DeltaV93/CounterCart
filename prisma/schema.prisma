generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  // directUrl is optional - only needed for Supabase connection pooler
  // For Railway PostgreSQL, just use DATABASE_URL
}

model User {
  id                  String    @id @default(cuid())
  email               String    @unique
  name                String?
  stripeCustomerId    String?   @unique
  subscriptionTier    String    @default("free") // "free" | "premium"
  subscriptionStatus  String?   // "active" | "canceled" | "past_due"
  donationMultiplier  Decimal   @default(1.0) @db.Decimal(3, 2)
  monthlyLimit        Decimal?  @db.Decimal(10, 2)
  currentMonthTotal   Decimal   @default(0) @db.Decimal(10, 2)
  monthlyResetAt      DateTime  @default(now())
  autoDonateEnabled   Boolean   @default(false)
  onboardingComplete  Boolean   @default(false)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Notification preferences
  notifyDonationComplete   Boolean @default(true)
  notifyWeeklySummary      Boolean @default(true)
  notifyNewMatch           Boolean @default(false)
  notifyPaymentFailed      Boolean @default(true)
  notifyBankDisconnected   Boolean @default(true)

  plaidItems      PlaidItem[]
  userCauses      UserCause[]
  userCharities   UserCharity[]
  transactions    Transaction[]
  donations       Donation[]
  donationBatches DonationBatch[]

  @@index([email])
  @@index([stripeCustomerId])
}

model PlaidItem {
  id              String          @id @default(cuid())
  userId          String
  accessToken     String          // Encrypted with AES-256-GCM
  itemId          String          @unique
  institutionId   String
  institutionName String
  cursor          String?         // For transaction sync pagination
  status          PlaidItemStatus @default(ACTIVE)
  errorCode       String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankAccounts BankAccount[]

  @@index([userId])
  @@index([itemId])
}

enum PlaidItemStatus {
  ACTIVE
  LOGIN_REQUIRED
  ERROR
  DISCONNECTED
}

model BankAccount {
  id             String   @id @default(cuid())
  plaidItemId    String
  plaidAccountId String   @unique
  name           String
  officialName   String?
  type           String   // checking, savings, credit
  subtype        String?
  mask           String?  // Last 4 digits
  isActive       Boolean  @default(true)
  createdAt      DateTime @default(now())

  plaidItem    PlaidItem     @relation(fields: [plaidItemId], references: [id], onDelete: Cascade)
  transactions Transaction[]

  @@index([plaidItemId])
  @@index([plaidAccountId])
}

model Cause {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?
  iconName    String?  // Lucide icon name
  color       String?  // Tailwind color class
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  userCauses       UserCause[]
  businessMappings BusinessMapping[]
  charities        Charity[]

  @@index([slug])
}

model UserCause {
  id        String   @id @default(cuid())
  userId    String
  causeId   String
  priority  Int      @default(1)
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  cause Cause @relation(fields: [causeId], references: [id], onDelete: Cascade)

  @@unique([userId, causeId])
  @@index([userId])
}

model UserCharity {
  id        String   @id @default(cuid())
  userId    String
  causeId   String
  charityId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  charity Charity @relation(fields: [charityId], references: [id], onDelete: Cascade)

  @@unique([userId, causeId])
  @@index([userId])
  @@index([charityId])
}

model BusinessMapping {
  id              String   @id @default(cuid())
  merchantPattern String   // Pattern to match against merchant names (case-insensitive)
  merchantName    String   // Human-readable display name
  causeId         String
  charitySlug     String   // Every.org charity slug
  charityName     String
  reason          String?  // Why this business is mapped to this cause
  confidence      Decimal  @default(1.0) @db.Decimal(3, 2)
  source          String   @default("manual") // "manual" | "community" | "verified"
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  cause        Cause         @relation(fields: [causeId], references: [id])
  transactions Transaction[]

  @@index([merchantPattern])
  @@index([causeId])
  @@index([isActive])
}

model Charity {
  id           String   @id @default(cuid())
  causeId      String
  everyOrgSlug String   @unique
  name         String
  description  String?
  ein          String?  // Tax ID
  logoUrl      String?
  websiteUrl   String?
  isDefault    Boolean  @default(false)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())

  cause         Cause         @relation(fields: [causeId], references: [id])
  donations     Donation[]
  userCharities UserCharity[]

  @@index([causeId])
  @@index([everyOrgSlug])
  @@index([causeId, isDefault])
}

model Transaction {
  id                 String            @id @default(cuid())
  userId             String
  bankAccountId      String
  plaidTransactionId String            @unique
  merchantName       String
  merchantNameNorm   String            // Normalized for matching
  amount             Decimal           @db.Decimal(10, 2)
  date               DateTime          @db.Date
  category           String[]
  matchedMappingId   String?
  status             TransactionStatus @default(PENDING)
  createdAt          DateTime          @default(now())

  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  bankAccount    BankAccount      @relation(fields: [bankAccountId], references: [id])
  matchedMapping BusinessMapping? @relation(fields: [matchedMappingId], references: [id])
  donation       Donation?

  @@index([userId, date])
  @@index([plaidTransactionId])
  @@index([merchantNameNorm])
  @@index([status])
  @@index([userId, status, date])
}

enum TransactionStatus {
  PENDING
  MATCHED
  BATCHED
  DONATED
  SKIPPED
  FAILED
}

model DonationBatch {
  id          String            @id @default(cuid())
  userId      String
  weekOf      DateTime          @db.Date // Sunday of the week
  totalAmount Decimal           @db.Decimal(10, 2)
  status      DonationBatchStatus @default(PENDING)
  processedAt DateTime?
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  donations Donation[]

  @@unique([userId, weekOf])
  @@index([userId, status])
  @@index([weekOf])
}

enum DonationBatchStatus {
  PENDING
  READY
  PROCESSING
  COMPLETED
  FAILED
}

model Donation {
  id             String         @id @default(cuid())
  userId         String
  batchId        String?
  transactionId  String?        @unique
  charityId      String
  charitySlug    String
  charityName    String
  amount         Decimal        @db.Decimal(10, 2)
  status         DonationStatus @default(PENDING)
  everyOrgId     String?        @unique
  receiptUrl     String?
  errorMessage   String?
  createdAt      DateTime       @default(now())
  completedAt    DateTime?

  user        User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  batch       DonationBatch? @relation(fields: [batchId], references: [id])
  transaction Transaction?   @relation(fields: [transactionId], references: [id])
  charity     Charity        @relation(fields: [charityId], references: [id])

  @@index([userId, createdAt])
  @@index([status])
  @@index([batchId])
  @@index([everyOrgId])
}

enum DonationStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
}

model WebhookEvent {
  id          String        @id @default(cuid())
  source      String        // "plaid" | "stripe" | "every_org"
  eventType   String
  eventId     String?       // External event ID for idempotency
  payload     Json
  signature   String?
  processedAt DateTime?
  status      WebhookStatus @default(PENDING)
  error       String?
  retryCount  Int           @default(0)
  createdAt   DateTime      @default(now())

  @@unique([source, eventId])
  @@index([source, eventType])
  @@index([status])
  @@index([createdAt])
}

enum WebhookStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}
